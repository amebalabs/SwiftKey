name: Build and Release
on:
  push:
    branches-ignore:
      - main
    tags:
      - "v*.*.*"
      - "v*.*.*-beta.*"
  pull_request:
    branches:
      - main

permissions:
  contents: write
  pages: write
  id-token: write
env:
  XCODE_VERSION: "16.2.0"
  BUNDLE_ID: "com.ameba.SwiftKey"
  APP_NAME: "SwiftKey"
  BETA_FEED_URL: "https://amebalabs.github.io/swiftkey/appcast_beta.xml"
  PROD_FEED_URL: "https://amebalabs.github.io/swiftkey/appcast.xml"

jobs:
  verify-release-notes:
    if: startsWith(github.ref, 'refs/tags/v') && github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      release_notes: ${{ steps.read_notes.outputs.content }}
    steps:
      - uses: actions/checkout@v3
      - name: Get version
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
      - name: Check release notes exist
        id: check_notes
        run: |
          VERSION=${{ steps.get_version.outputs.VERSION }}
          NOTES_PATH="docs/release-notes/${VERSION}.md"
          if [ ! -f "$NOTES_PATH" ]; then
            echo "Error: Release notes not found for version ${VERSION}"
            echo "Expected path: ${NOTES_PATH}"
            exit 1
          fi
      - name: Read release notes
        id: read_notes
        run: |
          VERSION=${{ steps.get_version.outputs.VERSION }}
          NOTES_PATH="docs/release-notes/${VERSION}.md"
          CONTENT=$(cat "$NOTES_PATH" | perl -p -e 's/%/%25/g' | perl -p -e 's/\n/%0A/g' | perl -p -e 's/\r/%0D/g')
          echo "content=$CONTENT" >> $GITHUB_OUTPUT

  build:
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name != github.repository
    runs-on: macos-latest
    timeout-minutes: 30
    outputs:
      build_number: ${{ steps.get_commit_count.outputs.BUILD_NUMBER }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get Version Numbers
        id: get_versions
        run: |
          # Get build number from commit count
          echo "BUILD_NUMBER=$(git rev-list --count HEAD)" >> $GITHUB_OUTPUT

          # Get version from tag or set development version
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # Remove 'v' prefix from tag
            echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          else
            echo "VERSION=0.0.0" >> $GITHUB_OUTPUT
          fi

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: ${{ env.XCODE_VERSION }}

      - name: Update Info.plist Version
        run: |
          # Path to your Info.plist
          PLIST_PATH="SwiftKey/Resources/Info.plist"

          # Update CFBundleShortVersionString (semantic version)
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString ${{ steps.get_versions.outputs.VERSION }}" "$PLIST_PATH"

          # Update CFBundleVersion (build number)
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion ${{ steps.get_versions.outputs.BUILD_NUMBER }}" "$PLIST_PATH"

          # Verify the changes
          echo "Updated versions in Info.plist:"
          /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$PLIST_PATH"
          /usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "$PLIST_PATH"

      - name: Build Application
        run: |
          xcodebuild -scheme "${{ env.APP_NAME }}" \
            -configuration Release \
            -derivedDataPath build \
            -arch arm64 -arch x86_64 \
            ONLY_ACTIVE_ARCH=NO \
            BUILD_NUMBER="${{ steps.get_commit_count.outputs.BUILD_NUMBER }}"
            MARKETING_VERSION="${{ steps.get_versions.outputs.VERSION }}" \
            CURRENT_PROJECT_VERSION="${{ steps.get_versions.outputs.BUILD_NUMBER }}"

      - name: Verify Universal Binary
        run: |
          echo "Checking binary architectures..."
          lipo -archs "build/Build/Products/Release/${{ env.APP_NAME }}.app/Contents/MacOS/${{ env.APP_NAME }}"
      - name: Package App Bundle
        run: |
          cd build/Build/Products/Release
          ditto -c -k --keepParent "${{ env.APP_NAME }}.app" "${{ env.APP_NAME }}.app.zip"
      - name: Upload App Bundle
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-Unsigned
          path: build/Build/Products/Release/${{ env.APP_NAME }}.app.zip
          retention-days: 5

  sign:
    needs: build
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      - name: Download Unsigned App
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-Unsigned
          path: .
      - name: Unpack App Bundle
        run: |
          ditto -x -k "${{ env.APP_NAME }}.app.zip" .
      - name: Sign Application
        uses: ./.github/actions/sign
        with:
          certificate: ${{ secrets.CERTIFICATES_P12 }}
          certificate-password: ${{ secrets.CERTIFICATES_P12_PASSWORD }}
          apple-team-id: ${{ secrets.TEAM_ID }}
          app-path: "${{ env.APP_NAME }}.app"
          entitlements-path: "SwiftKey/Resources/SwiftKey.entitlements"
      - name: Package Signed App Bundle
        run: |
          ditto -c -k --keepParent "${{ env.APP_NAME }}.app" "${{ env.APP_NAME }}.app.zip"
      - name: Upload Signed App Bundle
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-Signed
          path: ${{ env.APP_NAME }}.app.zip
          retention-days: 5

  notarize:
    needs: sign
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      - name: Download Signed App
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-Signed
          path: .
      - name: Unpack App Bundle
        run: |
          ditto -x -k "${{ env.APP_NAME }}.app.zip" .
      - name: Notarize Application
        uses: ./.github/actions/notarize
        with:
          username: ${{ secrets.APPLE_ID }}
          password: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          apple-team-id: ${{ secrets.TEAM_ID }}
          app-path: "${{ env.APP_NAME }}.app"
      - name: Package Notarized App Bundle
        run: |
          ditto -c -k --keepParent "${{ env.APP_NAME }}.app" "${{ env.APP_NAME }}.app.zip"
      - name: Upload Notarized App Bundle
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-Notarized
          path: ${{ env.APP_NAME }}.app.zip
          retention-days: 5

  release:
    needs: [notarize, verify-release-notes]
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Need full history for changelog

      - name: Set version variables
        run: |
          echo "VERSION=$(echo ${{ github.ref_name }} | sed 's/v//')" >> $GITHUB_ENV
          echo "IS_BETA=$(echo ${{ github.ref_name }} | grep -q 'beta' && echo 'true' || echo 'false')" >> $GITHUB_ENV
          echo "TAG=$(echo ${{ github.ref_name }})" >> $GITHUB_ENV

      - name: Download Notarized App
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-Notarized
          path: .

      - name: Unpack App Bundle
        run: |
          ditto -x -k "${{ env.APP_NAME }}.app.zip" .

      - name: Create Release Archive
        run: |
          ditto -c -k --keepParent "${{ env.APP_NAME }}.app" "${{ env.APP_NAME }}-${{ env.VERSION }}.zip"

      - name: Calculate SHA256
        run: |
          echo "ZIP_SHA=$(shasum -a 256 ${{ env.APP_NAME }}-${{ env.VERSION }}.zip | cut -d' ' -f1)" >> $GITHUB_ENV

      - name: Read Release Notes
        id: release_notes
        run: |
          NOTES_PATH="docs/release-notes/${{ env.TAG }}.md"
          if [ ! -f "$NOTES_PATH" ]; then
            echo "Error: Release notes not found at $NOTES_PATH"
            exit 1
          fi
          # Read and store release notes content
          CONTENT=$(cat "$NOTES_PATH")
          # Handle multiline content for GitHub Actions
          echo "RELEASE_NOTES<<EOF" >> $GITHUB_ENV
          echo "$CONTENT" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          # Also store just the content for the changelog update
          echo "content=$CONTENT" >> $GITHUB_OUTPUT

      - name: Update Appcast
        run: |
          # Determine which appcast to update
          IS_BETA="${{ env.IS_BETA }}"
          APPCAST_NAME="appcast$([ "$IS_BETA" == "true" ] && echo "_beta").xml"
          APPCAST_FILE="docs/$APPCAST_NAME"
          TEMPLATE_FILE="docs/templates/$APPCAST_NAME"

          # If appcast doesn't exist, copy from template
          if [ ! -f "$APPCAST_FILE" ]; then
            cp "$TEMPLATE_FILE" "$APPCAST_FILE"
          fi

          # Create a temporary file for the new item
          TEMP_ITEM=$(mktemp)

          # Generate new item content
          cat > "$TEMP_ITEM" << EOF
          <item>
              <title>${{ env.APP_NAME }} ${{ env.VERSION }}</title>
              <sparkle:version>${{ env.VERSION }}</sparkle:version>
              <sparkle:shortVersionString>${{ env.VERSION }}</sparkle:shortVersionString>
              <description><![CDATA[
          ${{ steps.release_notes.outputs.content }}
          ]]>
              </description>
              <pubDate>$(date -R)</pubDate>
              <enclosure
                  url="https://github.com/${{ github.repository }}/releases/download/${{ env.TAG }}/${{ env.APP_NAME }}-${{ env.VERSION }}.zip"
                  sparkle:version="${{ env.VERSION }}"
                  sparkle:shortVersionString="${{ env.VERSION }}"
                  length="$(stat -f%z "${{ env.APP_NAME }}-${{ env.VERSION }}.zip")"
                  type="application/octet-stream"
                  sparkle:edSignature="${{ steps.generate_signature.outputs.signature }}"
                  sparkle:sha256="${{ env.ZIP_SHA }}"
              />
          </item>
          EOF

          # Create temporary file for the new appcast
          TEMP_APPCAST=$(mktemp)

          # Extract previous items (everything between <!-- PREVIOUS_ITEMS --> and </channel>)
          PREVIOUS_ITEMS=$(awk '
            /<!-- PREVIOUS_ITEMS -->/ {p=1;next}
            /<\/channel>/ {p=0}
            p {print}
          ' "$APPCAST_FILE")

          # Construct new appcast
          cat > "$TEMP_APPCAST" << EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
              <channel>
                  <title>${{ env.APP_NAME }} $([ "$IS_BETA" == "true" ] && echo "Beta ")Appcast</title>
                  <link>$([ "$IS_BETA" == "true" ] && echo "${{ env.BETA_FEED_URL }}" || echo "${{ env.PROD_FEED_URL }}")</link>
                  <description>${{ env.APP_NAME }} $([ "$IS_BETA" == "true" ] && echo "Beta ")Updates</description>
                  <language>en</language>
                  <!-- LATEST_ITEM -->
          $(cat "$TEMP_ITEM")
                  <!-- PREVIOUS_ITEMS -->
          $PREVIOUS_ITEMS
              </channel>
          </rss>
          EOF

          # Replace the old appcast with the new one
          mv "$TEMP_APPCAST" "$APPCAST_FILE"

          # Clean up
          rm "$TEMP_ITEM"

          # Validate XML format
          xmllint --noout "$APPCAST_FILE" || {
            echo "Error: Invalid XML format in appcast"
            exit 1
          }

      - name: Update CHANGELOG.md
        run: |
          # Create temporary file
          TEMP_FILE=$(mktemp)

          # Add new release notes with header
          echo "# ${{ env.TAG }} ($(date +'%Y-%m-%d'))" > "$TEMP_FILE"
          echo "" >> "$TEMP_FILE"
          echo "${{ steps.release_notes.outputs.content }}" >> "$TEMP_FILE"
          echo "" >> "$TEMP_FILE"

          # Append existing changelog if it exists
          if [ -f "CHANGELOG.md" ]; then
            cat "CHANGELOG.md" >> "$TEMP_FILE"
          fi

          # Replace original changelog
          mv "$TEMP_FILE" "CHANGELOG.md"

      - name: Commit and Push Changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add CHANGELOG.md
          git add docs/appcast*.xml
          git commit -m "docs: update CHANGELOG.md and appcast for ${{ env.TAG }}"
          git push origin HEAD:main

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: ${{ env.APP_NAME }}-${{ env.VERSION }}.zip
          body: ${{ env.RELEASE_NOTES }}
          prerelease: ${{ env.IS_BETA == 'true' }}
          draft: false
          fail_on_unmatched_files: true
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs
          keep_files: true
  notify:
    needs: [build, sign, notarize]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Notify Status
        run: |
          echo "Build status: ${{ needs.build.result }}"
          echo "Sign status: ${{ needs.sign.result }}"
          echo "Notarize status: ${{ needs.notarize.result }}"
